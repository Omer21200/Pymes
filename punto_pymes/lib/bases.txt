-- ############################################################
-- === 0. LIMPIEZA TOTAL (REINICIO DE ESQUEMA) ===
-- ############################################################

-- Eliminamos triggers y funciones
DROP TRIGGER IF EXISTS trg_sync_profile_jwt ON public.profiles;
DROP FUNCTION IF EXISTS public.sync_profile_to_jwt();
DROP FUNCTION IF EXISTS public.create_company_and_admin_request(text, text, text, text, text, text);
DROP FUNCTION IF EXISTS public.register_employee_rpc(text, text, text, text);
DROP FUNCTION IF EXISTS public.register_admin_request_rpc(text, text);
DROP FUNCTION IF EXISTS public.handle_user_confirmed();
DROP FUNCTION IF EXISTS public.obtener_horario_esperado(uuid, date);
DROP FUNCTION IF EXISTS public.es_feriado(uuid, date);
DROP FUNCTION IF EXISTS public.get_asistencias_con_estado(uuid, uuid, date, date);

-- Eliminamos políticas (para evitar errores de duplicidad)
DROP POLICY IF EXISTS "superadmin_empresas_all" ON public.empresas;
DROP POLICY IF EXISTS "admin_empresas_own" ON public.empresas;
DROP POLICY IF EXISTS "public_ver_empresas" ON public.empresas;
DROP POLICY IF EXISTS "superadmin_profiles_all" ON public.profiles;
DROP POLICY IF EXISTS "user_own_profile" ON public.profiles;
DROP POLICY IF EXISTS "admin_ver_profiles_empresa" ON public.profiles;
DROP POLICY IF EXISTS "user_insert_own_profile" ON public.profiles;
DROP POLICY IF EXISTS "superadmin_empleados" ON public.empleados;
DROP POLICY IF EXISTS "admin_gestion_empleados" ON public.empleados;
DROP POLICY IF EXISTS "empleado_ver_propio" ON public.empleados;
DROP POLICY IF EXISTS "superadmin_asistencias" ON public.asistencias;
DROP POLICY IF EXISTS "admin_asistencias_empresa" ON public.asistencias;
DROP POLICY IF EXISTS "empleado_gestion_asistencias" ON public.asistencias;
DROP POLICY IF EXISTS "superadmin_horarios_all" ON public.horarios_departamento;
DROP POLICY IF EXISTS "admin_horarios_empresa" ON public.horarios_departamento;
DROP POLICY IF EXISTS "superadmin_feriados_all" ON public.feriados;
DROP POLICY IF EXISTS "admin_feriados_empresa" ON public.feriados;
DROP POLICY IF EXISTS "auth_ver_feriados" ON public.feriados;
DROP POLICY IF EXISTS "Deny all on registration_requests" ON public.registration_requests;
DROP POLICY IF EXISTS "Deny all on admin_registration_requests" ON public.admin_registration_requests;
DROP POLICY IF EXISTS "todos_leen_roles" ON public.roles;
DROP POLICY IF EXISTS "superadmin_modifica_roles" ON public.roles;


-- Eliminamos vistas (Orden correcto por dependencias)
DROP VIEW IF EXISTS public.v_asistencias_con_estado;

-- Eliminamos tablas (Orden correcto por dependencias)
DROP TABLE IF EXISTS public.horarios_departamento CASCADE;
DROP TABLE IF EXISTS public.feriados CASCADE;
DROP TABLE IF EXISTS public.documentos_empleado CASCADE;
DROP TABLE IF EXISTS public.asistencias CASCADE;
DROP TABLE IF EXISTS public.contratos CASCADE;
DROP TABLE IF EXISTS public.empleado_cargo CASCADE;
DROP TABLE IF EXISTS public.cargos CASCADE;
DROP TABLE IF EXISTS public.empleados CASCADE;
DROP TABLE IF EXISTS public.departamentos CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;
DROP TABLE IF EXISTS public.empresas CASCADE;
DROP TABLE IF EXISTS public.roles CASCADE;
DROP TABLE IF EXISTS public.admin_registration_requests;
DROP TABLE IF EXISTS public.registration_requests; -- Tabla auxiliar de registro

CREATE EXTENSION IF NOT EXISTS pgcrypto;

---

-- ############################################################
-- === 1. CREACIÓN DE TABLAS PRINCIPALES ===
-- ############################################################

CREATE TABLE public.roles (
  id serial primary key,
  nombre text unique not null
);
INSERT INTO public.roles (nombre) VALUES ('SUPER_ADMIN'), ('ADMIN_EMPRESA'), ('EMPLEADO');

CREATE TABLE public.empresas (
  id uuid primary key default gen_random_uuid(),
  nombre text not null,
  ruc text unique,
  -- Código de acceso para registro de EMPLEADOS
  codigo_acceso_empleado text unique not null, 
  direccion text,
  telefono text,
  correo text,
  empresa_foto_url text,
  latitud numeric(10,6),
  longitud numeric(10,6),
  created_at timestamp default now()
);

-- Tabla auxiliar para pre-registrar administradores (Solo Super Admin crea esta fila)
CREATE TABLE public.admin_registration_requests (
    email text PRIMARY KEY,
    empresa_id uuid NOT NULL REFERENCES public.empresas(id) ON DELETE CASCADE,
    -- Código de acceso único para registro de ADMINS
    access_code text UNIQUE NOT NULL, 
    nombres text NOT NULL,
    apellidos text NOT NULL,
    created_at timestamp default now()
);

-- Tabla auxiliar para que el trigger de Auth recoja los datos (Empleado o Admin)
CREATE TABLE public.registration_requests (
  email text PRIMARY KEY,
  company_id uuid NOT NULL,
  code text NOT NULL, -- Contiene el código de empresa (Empleado) o el código de admin (Admin)
  created_at timestamptz DEFAULT now()
);

CREATE TABLE public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  rol text not null check (rol in ('SUPER_ADMIN','ADMIN_EMPRESA','EMPLEADO')),
  empresa_id uuid references public.empresas(id) on delete set null,
  nombres text,
  apellidos text,
  foto_url text,
  -- COLUMNA AÑADIDA para el formulario de Flutter que solicitaste
  company text, 
  created_at timestamp default now()
);

CREATE TABLE public.departamentos (
  id uuid primary key default gen_random_uuid(),
  empresa_id uuid not null references public.empresas(id) on delete cascade,
  nombre text not null,
  descripcion text,
  created_at timestamp default now()
);

CREATE TABLE public.empleados (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  empresa_id uuid not null references public.empresas(id) on delete cascade,
  departamento_id uuid references public.departamentos(id) on delete set null,
  nombres text not null,
  apellidos text not null,
  cedula text unique,
  correo text unique,
  estado text default 'activo',
  registro_latitud numeric(10,6),
  registro_longitud numeric(10,6),
  created_at timestamp default now(),
  CONSTRAINT empleados_user_id_unique UNIQUE (user_id)
);

CREATE TABLE public.asistencias (
  id uuid primary key default gen_random_uuid(),
  empleado_id uuid not null references public.empleados(id) on delete cascade,
  fecha date not null default current_date,
  hora_entrada time,
  hora_salida time,
  latitud numeric(10,6),
  longitud numeric(10,6),
  foto_url text,
  estado text default 'pendiente',
  observacion text,
  created_at timestamp default now()
);

CREATE TABLE public.horarios_departamento (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  departamento_id uuid NOT NULL REFERENCES public.departamentos(id) ON DELETE CASCADE,
  lunes boolean DEFAULT true,
  martes boolean DEFAULT true,
  miercoles boolean DEFAULT true,
  jueves boolean DEFAULT true,
  viernes boolean DEFAULT true,
  sabado boolean DEFAULT false,
  domingo boolean DEFAULT false,
  hora_entrada time NOT NULL DEFAULT '08:00:00',
  hora_salida time NOT NULL DEFAULT '17:00:00',
  tolerancia_entrada_minutos int DEFAULT 10,
  created_at timestamp DEFAULT now(),
  updated_at timestamp DEFAULT now(),
  CONSTRAINT unique_horario_activo_por_departamento UNIQUE (departamento_id)
);
CREATE INDEX idx_horarios_departamento_depto ON public.horarios_departamento(departamento_id);

CREATE TABLE public.feriados (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  empresa_id uuid REFERENCES public.empresas(id) ON DELETE CASCADE,
  fecha date NOT NULL,
  nombre text NOT NULL,
  tipo text DEFAULT 'nacional' CHECK (tipo IN ('nacional', 'local', 'puente', 'recuperable')),
  recuperable boolean DEFAULT false,
  created_at timestamp DEFAULT now(),
  UNIQUE(empresa_id, fecha)
);
CREATE INDEX idx_feriados_fecha ON public.feriados(fecha);
CREATE INDEX idx_feriados_empresa_fecha ON public.feriados(empresa_id, fecha);


---

-- ############################################################
-- === 2. FUNCIONES DE REGISTRO SEGURO Y PERFIL ===
-- ############################################################

-- 2.1) RPC para EMPLEADOS (Registro simple por código de empresa)
CREATE OR REPLACE FUNCTION public.register_employee_rpc(
    p_email text,
    p_code text
)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_empresa_id uuid;
BEGIN
    -- 1. Validar el código de empleado y obtener el empresa_id
    SELECT id INTO v_empresa_id FROM public.empresas
    WHERE codigo_acceso_empleado = p_code;

    IF v_empresa_id IS NULL THEN
        RAISE EXCEPTION 'Código de empresa inválido o no existe.';
    END IF;

    -- 2. Insertar en la tabla temporal de registro para que el trigger lo recoja
    INSERT INTO public.registration_requests (email, company_id, code)
    VALUES (p_email, v_empresa_id, p_code)
    ON CONFLICT (email) DO UPDATE 
        SET company_id = EXCLUDED.company_id, code = EXCLUDED.code, created_at = now(); 

    RETURN TRUE;
EXCEPTION
    WHEN others THEN
        RETURN FALSE;
END;
$$;
GRANT EXECUTE ON FUNCTION public.register_employee_rpc(text, text) TO anon, authenticated;


-- 2.2) RPC para ADMINISTRADORES (Registro por código de acceso y correo pre-registrado)
CREATE OR REPLACE FUNCTION public.register_admin_request_rpc(
    p_email text,
    p_access_code text
)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    req record;
BEGIN
    -- 1. Validar el código de acceso y obtener el request
    SELECT * INTO req FROM public.admin_registration_requests
    WHERE email = p_email AND access_code = p_access_code;

    IF NOT found THEN
        RAISE EXCEPTION 'Correo o Código de Acceso de Administrador inválido.';
    END IF;

    -- 2. Usar la tabla auxiliar de registro para que el trigger de Auth lo recoja
    INSERT INTO public.registration_requests (email, company_id, code)
    VALUES (p_email, req.empresa_id, p_access_code)
    ON CONFLICT (email) DO UPDATE 
        SET company_id = EXCLUDED.company_id, code = EXCLUDED.code, created_at = now(); 

    RETURN TRUE;
EXCEPTION
    WHEN others THEN
        RETURN FALSE;
END;
$$;
GRANT EXECUTE ON FUNCTION public.register_admin_request_rpc(text, text) TO anon, authenticated;


-- 2.3) Función handle_user_confirmed ajustada para asumir roles
CREATE OR REPLACE FUNCTION public.handle_user_confirmed()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  req record;
  admin_req record;
  v_rol text := 'EMPLEADO';
  v_nombres text;
  v_apellidos text;
BEGIN
  IF (TG_OP = 'INSERT' AND NEW.confirmed_at IS NOT NULL) OR
     (TG_OP = 'UPDATE' AND OLD.confirmed_at IS NULL AND NEW.confirmed_at IS NOT NULL) THEN

    -- Buscar solicitud de registro (para Empleado o Admin)
    SELECT * INTO req FROM public.registration_requests WHERE email = NEW.email LIMIT 1;

    IF found THEN
        -- 1. Intentar encontrar si es un registro de Administrador
        SELECT * INTO admin_req FROM public.admin_registration_requests 
        WHERE email = NEW.email AND access_code = req.code AND empresa_id = req.company_id;

        IF found THEN
            v_rol := 'ADMIN_EMPRESA';
            v_nombres := admin_req.nombres;
            v_apellidos := admin_req.apellidos;
        END IF;

        -- 2. Insertar perfil con el rol y nombres correctos
        INSERT INTO public.profiles (id, rol, empresa_id, nombres, apellidos, created_at, updated_at)
        VALUES (NEW.id, v_rol, req.company_id, v_nombres, v_apellidos, now(), now())
        ON CONFLICT (id) DO UPDATE
            SET rol = EXCLUDED.rol,
                empresa_id = COALESCE(public.profiles.empresa_id, excluded.empresa_id),
                nombres = COALESCE(public.profiles.nombres, excluded.nombres),
                apellidos = COALESCE(public.profiles.apellidos, excluded.apellidos),
                updated_at = now();

        -- 3. Limpiar ambas tablas de registro (si aplica)
        DELETE FROM public.registration_requests WHERE email = NEW.email;
        DELETE FROM public.admin_registration_requests WHERE email = NEW.email;
    ELSE
      -- No hay solicitud, crear fila de perfil vacía (Rol por defecto: EMPLEADO/GUEST)
      INSERT INTO public.profiles (id, rol, created_at, updated_at)
      VALUES (NEW.id, 'EMPLEADO', now(), now())
      ON CONFLICT (id) DO NOTHING;
    END IF;
  END IF;
  RETURN NEW;
END;
$$;


-- 2.4) Sincronización JWT (se mantiene)
CREATE OR REPLACE FUNCTION public.sync_profile_to_jwt()
RETURNS trigger AS $$
BEGIN
  UPDATE auth.users
  SET raw_app_meta_data = 
    COALESCE(raw_app_meta_data, '{}'::jsonb) || 
    jsonb_build_object('role', NEW.rol, 'empresa_id', NEW.empresa_id::text)
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- 2.5) Triggers
CREATE TRIGGER trg_sync_profile_jwt
AFTER INSERT OR UPDATE ON public.profiles
FOR EACH ROW EXECUTE FUNCTION public.sync_profile_to_jwt();

CREATE TRIGGER trigger_handle_user_confirmed_insert
  AFTER INSERT ON auth.users
  FOR EACH ROW
  WHEN (new.confirmed_at IS NOT NULL)
  EXECUTE PROCEDURE public.handle_user_confirmed();

CREATE TRIGGER trigger_handle_user_confirmed_update
  AFTER UPDATE ON auth.users
  FOR EACH ROW
  WHEN (old.confirmed_at IS NULL AND new.confirmed_at IS NOT NULL)
  EXECUTE PROCEDURE public.handle_user_confirmed();


---

-- ############################################################
-- === 3. FUNCIÓN DE SUPER ADMIN (Creación de Empresa y Admin Request) ===
-- ############################################################

CREATE OR REPLACE FUNCTION public.create_company_and_admin_request(
    p_nombre_empresa text,
    p_codigo_acceso_empleado text,
    p_email_admin text,
    p_codigo_admin text,
    p_nombres_admin text,
    p_apellidos_admin text
)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_empresa_id uuid;
BEGIN
    -- 1. Verificar permisos (Solo Super Admin)
    IF (auth.jwt() -> 'app_metadata' ->> 'role') <> 'SUPER_ADMIN' THEN
        RAISE EXCEPTION 'Acceso denegado: Solo Super Admin puede crear empresas y admins.';
    END IF;

    -- 2. Crear la empresa
    INSERT INTO public.empresas (nombre, codigo_acceso_empleado)
    VALUES (p_nombre_empresa, p_codigo_acceso_empleado)
    RETURNING id INTO v_empresa_id;

    -- 3. Crear la solicitud de registro del administrador
    INSERT INTO public.admin_registration_requests (email, empresa_id, access_code, nombres, apellidos)
    VALUES (p_email_admin, v_empresa_id, p_codigo_admin, p_nombres_admin, p_apellidos_admin);

    RETURN v_empresa_id;
END;
$$;
GRANT EXECUTE ON FUNCTION public.create_company_and_admin_request(text, text, text, text, text, text) TO authenticated;

---

-- ############################################################
-- === 4. RLS y POLÍTICAS DE ACCESO ===
-- ############################################################

ALTER TABLE public.empresas ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.departamentos ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.empleados ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.asistencias ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.horarios_departamento ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.feriados ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.registration_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.admin_registration_requests ENABLE ROW LEVEL SECURITY;

-- EMPRESAS
CREATE POLICY "superadmin_empresas_all" ON public.empresas FOR ALL USING ((auth.jwt() -> 'app_metadata' ->> 'role') = 'SUPER_ADMIN');
CREATE POLICY "admin_empresas_own" ON public.empresas FOR ALL USING (id::text = (auth.jwt() -> 'app_metadata' ->> 'empresa_id'));
CREATE POLICY "public_ver_empresas" ON public.empresas FOR SELECT USING (auth.role() = 'authenticated');

-- PROFILES
CREATE POLICY "superadmin_profiles_all" ON public.profiles FOR ALL USING ((auth.jwt() -> 'app_metadata' ->> 'role') = 'SUPER_ADMIN');
CREATE POLICY "user_own_profile" ON public.profiles FOR ALL USING (id = auth.uid()) WITH CHECK (id = auth.uid());
CREATE POLICY "admin_ver_profiles_empresa" ON public.profiles FOR SELECT USING ((auth.jwt() -> 'app_metadata' ->> 'role') = 'ADMIN_EMPRESA' AND empresa_id::text = (auth.jwt() -> 'app_metadata' ->> 'empresa_id'));
CREATE POLICY "user_insert_own_profile" ON public.profiles FOR INSERT WITH CHECK (id = auth.uid());

-- EMPLEADOS
CREATE POLICY "superadmin_empleados" ON public.empleados FOR ALL USING ((auth.jwt() -> 'app_metadata' ->> 'role') = 'SUPER_ADMIN');
CREATE POLICY "admin_gestion_empleados" ON public.empleados FOR ALL USING (empresa_id::text = (auth.jwt() -> 'app_metadata' ->> 'empresa_id'));
CREATE POLICY "empleado_ver_propio" ON public.empleados FOR SELECT USING (user_id = auth.uid());

-- ASISTENCIAS
CREATE POLICY "superadmin_asistencias" ON public.asistencias FOR ALL USING ((auth.jwt() -> 'app_metadata' ->> 'role') = 'SUPER_ADMIN');
CREATE POLICY "admin_asistencias_empresa" ON public.asistencias FOR SELECT USING (empleado_id IN (SELECT id FROM public.empleados WHERE empresa_id::text = (auth.jwt() -> 'app_metadata' ->> 'empresa_id')));
CREATE POLICY "empleado_gestion_asistencias" ON public.asistencias FOR ALL USING (empleado_id IN (SELECT id FROM public.empleados WHERE user_id = auth.uid()));

-- TABLAS DE REGISTRO AUXILIAR (Acceso denegado a todos)
CREATE POLICY "Deny all on registration_requests" ON public.registration_requests FOR ALL USING (false);
CREATE POLICY "Deny all on admin_registration_requests" ON public.admin_registration_requests FOR ALL USING (false);

-- ROLES (Catálogo)
CREATE POLICY "todos_leen_roles" ON public.roles FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "superadmin_modifica_roles" ON public.roles FOR ALL USING ((auth.jwt() -> 'app_metadata' ->> 'role') = 'SUPER_ADMIN') WITH CHECK ((auth.jwt() -> 'app_metadata' ->> 'role') = 'SUPER_ADMIN');


---

-- ############################################################
-- === 5. FUNCIONES DE LÓGICA DE NEGOCIO Y VISTAS (Se mantienen) ===
-- ############################################################

-- Función Lógica: Es feriado
CREATE OR REPLACE FUNCTION public.es_feriado(p_empleado_id uuid, p_fecha date DEFAULT current_date)
RETURNS boolean LANGUAGE sql STABLE AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.feriados f
    JOIN public.empleados e ON f.empresa_id IS NOT DISTINCT FROM e.empresa_id
    WHERE e.id = p_empleado_id AND f.fecha = p_fecha
  );
$$;

-- Función Lógica: Obtener horario esperado según día y departamento
CREATE OR REPLACE FUNCTION public.obtener_horario_esperado(p_empleado_id uuid, p_fecha date DEFAULT current_date)
RETURNS TABLE (hora_entrada_esperada time, hora_salida_esperada time, tolerancia_minutos int)
LANGUAGE plpgsql STABLE AS $$
DECLARE v_dia_semana text;
BEGIN
  v_dia_semana := LOWER(TO_CHAR(p_fecha, 'Day'));
  RETURN QUERY
  SELECT hd.hora_entrada, hd.hora_salida, hd.tolerancia_entrada_minutos
  FROM public.empleados e
  JOIN public.departamentos d ON e.departamento_id = d.id
  LEFT JOIN public.horarios_departamento hd ON hd.departamento_id = d.id
  WHERE e.id = p_empleado_id
    AND ((v_dia_semana LIKE 'monday%' AND hd.lunes) OR
         (v_dia_semana LIKE 'tuesday%' AND hd.martes) OR
         (v_dia_semana LIKE 'wednesday%' AND hd.miercoles) OR
         (v_dia_semana LIKE 'thursday%' AND hd.jueves) OR
         (v_dia_semana LIKE 'friday%' AND hd.viernes) OR
         (v_dia_semana LIKE 'saturday%' AND hd.sabado) OR
         (v_dia_semana LIKE 'sunday%' AND hd.domingo));
END;
$$;


-- Función segura para obtener asistencias (reemplaza la vista)
CREATE OR REPLACE FUNCTION public.get_asistencias_con_estado(
  p_empleado_id uuid DEFAULT NULL,
  p_empresa_id uuid DEFAULT NULL,
  p_fecha_desde date DEFAULT NULL,
  p_fecha_hasta date DEFAULT NULL
)
RETURNS TABLE (
  asistencia_id uuid, empleado_id uuid, empleado_nombre text, cedula text, departamento text,
  fecha date, hora_entrada time, hora_salida time, es_feriado boolean,
  estado_entrada text, estado_salida text, hora_entrada_esperada time, hora_salida_esperada time,
  tolerancia_minutos int
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  current_role text := (auth.jwt() -> 'app_metadata' ->> 'role');
  current_empresa_id text := (auth.jwt() -> 'app_metadata' ->> 'empresa_id');
BEGIN
  RETURN QUERY
  SELECT 
    a.id, a.empleado_id, e.nombres || ' ' || e.apellidos, e.cedula, d.nombre, a.fecha, a.hora_entrada, a.hora_salida,
    COALESCE(public.es_feriado(a.empleado_id, a.fecha), false),
    CASE 
      WHEN public.es_feriado(a.empleado_id, a.fecha) THEN 'Feriado'
      WHEN a.hora_entrada IS NULL AND a.fecha < current_date THEN 'Falta'
      WHEN a.hora_entrada IS NULL THEN 'Pendiente'
      WHEN a.hora_entrada <= (h.hora_entrada_esperada + (h.tolerancia_minutos * interval '1 minute')) THEN 'A tiempo'
      ELSE 'Tarde'
    END,
    CASE 
      WHEN public.es_feriado(a.empleado_id, a.fecha) THEN 'Feriado'
      WHEN a.hora_salida IS NOT NULL AND a.hora_salida < h.hora_salida_esperada - interval '30 minutes' THEN 'Salida temprana'
      WHEN a.hora_salida IS NOT NULL THEN 'Completa'
      WHEN a.hora_entrada IS NOT NULL AND a.fecha < current_date THEN 'Incompleta'
      ELSE 'Pendiente'
    END,
    h.hora_entrada_esperada, h.hora_salida_esperada, h.tolerancia_minutos
  FROM public.asistencias a
  JOIN public.empleados e ON a.empleado_id = e.id
  LEFT JOIN public.departamentos d ON e.departamento_id = d.id
  LEFT JOIN LATERAL public.obtener_horario_esperado(a.empleado_id, a.fecha) h ON true
  WHERE
    (p_empleado_id IS NULL OR a.empleado_id = p_empleado_id)
    AND (p_empresa_id IS NULL OR e.empresa_id = p_empresa_id)
    AND (p_fecha_desde IS NULL OR a.fecha >= p_fecha_desde)
    AND (p_fecha_hasta IS NULL OR a.fecha <= p_fecha_hasta)
    AND (
      current_role = 'SUPER_ADMIN'
      OR (current_role = 'ADMIN_EMPRESA' AND e.empresa_id::text = current_empresa_id)
      OR (current_role = 'EMPLEADO' AND e.user_id = auth.uid())
    );
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_asistencias_con_estado(uuid, uuid, date, date) TO authenticated;


---

-- ############################################################
-- === 6. DATOS INICIALES ===
-- ############################################################

-- 6.1) Configuración inicial de Super Admin
-- Asegúrate de que el email 'omerbenitez2000@gmail.com' esté registrado en Auth.users
INSERT INTO public.profiles (id, rol, nombres, apellidos, empresa_id)
VALUES ((SELECT id FROM auth.users WHERE email = 'omerbenitez2000@gmail.com'), 'SUPER_ADMIN', 'Super', 'Admin', NULL)
ON CONFLICT (id) DO UPDATE SET rol = 'SUPER_ADMIN', empresa_id = NULL;

UPDATE auth.users
SET raw_app_meta_data = COALESCE(raw_app_meta_data, '{}'::jsonb) || jsonb_build_object('role', 'SUPER_ADMIN', 'empresa_id', null)
WHERE email = 'omerbenitez2000@gmail.com';

-- 6.2) Feriados Ecuador 2025 (ejemplo)
INSERT INTO public.feriados (fecha, nombre, tipo) VALUES
('2025-01-01', 'Año Nuevo', 'nacional'),
('2025-02-24', 'Carnaval', 'nacional'),
('2025-02-25', 'Carnaval', 'nacional'),
('2025-04-18', 'Viernes Santo', 'nacional'),
('2025-05-01', 'Día del Trabajo', 'nacional'),
('2025-05-24', 'Batalla de Pichincha', 'nacional'),
('2025-08-10', 'Primer Grito de Independencia', 'nacional'),
('2025-10-09', 'Independencia de Guayaquil', 'nacional'),
('2025-11-02', 'Día de los Difuntos', 'nacional'),
('2025-11-03', 'Independencia de Cuenca', 'nacional'),
('2025-12-25', 'Navidad', 'nacional')
ON CONFLICT (empresa_id, fecha) DO NOTHING;